## Compose in Depth

in this article you will see everythingabout compose in-depth  it will take a long time to read  but has value

I going to explain about how compose works under the hood.

**how compose automatically updates the ui if happen any changes , how dose it do that ?**

in compose if you want to survive of recomposition you have to  use mutableStateOf in remember block.

```kt
val text= remember{ mutableStateOf(false)}
```

how it works ?

look at mutableState strucutre 

```kt
fun <T> mutableStateOf(
    value: T,
    policy: SnapshotMutationPolicy<T> = structuralEqualityPolicy()
)
```

mutableState has 2 parameters first  parameter is value and the second parameter  is `policy:SnapShotMutationPolicy` .

we always set the value for the first item and don't care about second item because it have a default value.

the compose Runtime keeps track of **MutableState** object in current composition means if you change the value held by **MutableState**

compose runtime will notice the change and schedule a recomposition that is where the second parameter `policy` comes, compose uses it to check if the value is changed.

##### look at structuralEqualityPoli structural:

```kt
fun <T> structuralEqualityPolicy(): SnapshotMutationPolicy<T> =
    StructuralEqualityPolicy as SnapshotMutationPolicy<T>

private object StructuralEqualityPolicy : SnapshotMutationPolicy<Any?> {
    override fun equivalent(a: Any?, b: Any?) = a == b

    override fun toString() = "StructuralEqualityPolicy"
}
```

As you can see `stucuralEqualityPolicy()` returns `SnapshotMutationPolicy<T>` it has an `equivalent()` method which receives values `a` and `b` one of them is new value we are setting one one is old value held by `MutableState<T>` these values are hopefully supplied by Compose Runtime.

`equivalent()` just checks `a != b` if `true` compose will schedule the recomposition otherwise not. 

That was about recomposition but only recomposition doesn’t work changing `State<T>` object causes a recomposition but new value is not supplied our `State<T>` will again initialized to old value like nothing has happened.

It turns out that **composables** can have their own memory so at time recompostion they can pick the old value that was held in that memory and use it.

To make compose track your value as well as save in **composables** memory you need to use `State<T>` with `remember{}`.

```kt
@Composable
inline fun <T> remember(calculation: @DisallowComposableCalls () -> T): T = currentComposer.cache(false, calculation)
```

`remember()` takes a calculation as a lambda and then use the `currentComposer` it references an instance of Composer. This interface is targeted by the Compose Kotlin compiler plugin and used by code generation helpers. You should not call it directly, because the runtime assumes that calls are generated by the compiler and therefore do not contain much validation logic. `cache()` is an extension function of Composer. It stores a value in the composition data of a composition.

```kt
@ComposeCompilerApi
inline fun <T> Composer.cache(invalid: Boolean, block: () -> T): T {
    @Suppress("UNCHECKED_CAST")
    return rememberedValue().let {
        if (invalid || it === Composer.Empty) {
            val value = block()
            updateRememberedValue(value)
            value
        } else it
    } as T
}
```

Now that is where the remember value is coming from, `rememberedValue()` function return a value saved in cache on composable, here they basically check whether of not we already have that value if not then only calculation happens and value gets updated otherwise the old value is returned.

----

### System UI controller   = rememberSystemUiController()

we want to going to change the system bar colors and when we say system bar actually we referring to navigation bar and status bar color 

for changing this color we have 2 option :

1- change parameter `"android:statusBarColor"` and `android:navigationBarColor`  for both  light theme.xml and dark theme.xml file 

2 - Using System UI Controller for jetpack compose 

- add  accompanist dependency ` implementation "com.google.accompanist:accompanist-systemuicontroller:<version>" }`

**System UI Controller** provides easy-to-use utilities for updating the System UI bar colors within Jetpack Compose.

To control the system UI in your composables, you need to get a [`SystemUiController`](https://google.github.io/accompanist/api/systemuicontroller/systemuicontroller/com.google.accompanist.systemuicontroller/-system-ui-controller/) instance. The library provides the [`rememberSystemUiController()`](https://google.github.io/accompanist/api/systemuicontroller/systemuicontroller/com.google.accompanist.systemuicontroller/remember-system-ui-controller.html) function which returns an instance for the current system (currently only Android).

you can update the system bar colors like so:

```kt
// Remember a SystemUiController
val systemUiController = rememberSystemUiController()
val useDarkIcons = !isSystemInDarkTheme()

DisposableEffect(systemUiController, useDarkIcons) {
    // Update all of the system bar colors to be transparent, and use
    // dark icons if we're in light theme
    systemUiController.setSystemBarsColor(
        color = Color.Transparent,
        darkIcons = useDarkIcons
    )

    // setStatusBarColor() and setNavigationBarColor() also exist

    onDispose {}
}
```

when we have type `systemUiController.`  it suggest 3 parameter 

1- setStatusBarColor                     /// change only status bar color 

2- setNavigationBarColor            /// change only navigation bar color

3- setSystemBarColor /// change both of those system bar colors

or we can using this

```kt
val systemUiController = rememberSystemUiController()
val darkTheme  = isSystemInDarkTheme()

SideEffect{
    systemUiController.setSystemBarColor(
    color = if (darkTheme) Color.LightGray else Yellow
)}
```

------------------------------

 look at this example 

```kt
Surface(
    color = MaterialTheme.colors.surface,
    contentColor = contentColorFor(color),
    // ...
) { /* ... */ }

TopAppBar(
    backgroundColor = MaterialTheme.colors.primarySurface,
    contentColor = contentColorFor(backgroundColor),
    // ...
) { /* ... */ }
```

The [`contentColorFor()`](https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#contentColorFor(androidx.compose.ui.graphics.Color)) method retrieves the appropriate "on" color for any theme colors. For example, if you set a [`primary`](https://developer.android.com/reference/kotlin/androidx/compose/material/Colors#primary()) background color on `Surface`, it uses this function to set [`onPrimary`](https://developer.android.com/reference/kotlin/androidx/compose/material/Colors#onPrimary()) as the content color. If you set a non-theme background color, you should also specify an appropriate content color. Use [`LocalContentColor`](https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#LocalContentColor()) to retrieve the preferred content color for the current background, at a given position in the hierarchy.



























resource :

https://blog.devgenius.io/making-sense-of-compose-magic-deep-dive-b03873910a67

https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050

https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd

https://medium.com/androiddevelopers/thinking-in-compose-c4ef150bb7cf

https://betterprogramming.pub/deep-dive-into-jetpack-compose-b09713760019

https://www.youtube.com/watch?v=K099Vg6_t1o

[Guide - Accompanist](https://google.github.io/accompanist/systemuicontroller/)
